#!/usr/bin/env python
from __future__ import print_function

import mimetypes
import random
import string
import argparse
import json
import logging
import sys
import os
import urllib
import urllib2
import base64
import collections
import tarfile
import StringIO

GROUP_KEY_ORDER = ["id", "creation_time", "name", "type", "memsize"]

_BOUNDARY_CHARS = string.digits + string.ascii_letters

def encode_multipart(fields, files, boundary=None):
    r"""Encode dict of form fields and dict of files as multipart/form-data.
    Return tuple of (body_string, headers_dict). Each value in files is a dict
    with required keys 'filename' and 'content', and optional 'mimetype' (if
    not specified, tries to guess mime type or uses 'application/octet-stream').

    >>> body, headers = encode_multipart({'FIELD': 'VALUE'},
    ...                                  {'FILE': {'filename': 'F.TXT', 'content': 'CONTENT'}},
    ...                                  boundary='BOUNDARY')
    >>> print('\n'.join(repr(l) for l in body.split('\r\n')))
    '--BOUNDARY'
    'Content-Disposition: form-data; name="FIELD"'
    ''
    'VALUE'
    '--BOUNDARY'
    'Content-Disposition: form-data; name="FILE"; filename="F.TXT"'
    'Content-Type: text/plain'
    ''
    'CONTENT'
    '--BOUNDARY--'
    ''
    >>> print(sorted(headers.items()))
    [('Content-Length', '193'), ('Content-Type', 'multipart/form-data; boundary=BOUNDARY')]
    >>> len(body)
    193
    """
    def escape_quote(s):
        return s.replace('"', '\\"')

    if boundary is None:
        boundary = ''.join(random.choice(_BOUNDARY_CHARS) for i in range(30))
    lines = []

    for name, value in fields.items():
        lines.extend((
            '--{0}'.format(boundary),
            'Content-Disposition: form-data; name="{0}"'.format(escape_quote(name)),
            '',
            str(value),
        ))

    for name, value in files.items():
        filename = value['filename']
        if 'mimetype' in value:
            mimetype = value['mimetype']
        else:
            mimetype = mimetypes.guess_type(filename)[0] or 'application/octet-stream'
        lines.extend((
            '--{0}'.format(boundary),
            'Content-Disposition: form-data; name="{0}"; filename="{1}"'.format(
                    escape_quote(name), escape_quote(filename)),
            'Content-Type: {0}'.format(mimetype),
            '',
            value['content'],
        ))

    lines.extend((
        '--{0}--'.format(boundary),
        '',
    ))
    body = '\r\n'.join(lines)

    headers = {
        'Content-Type': 'multipart/form-data; boundary={0}'.format(boundary),
        'Content-Length': str(len(body)),
    }

    return (body, headers)

def print_table(header, data):
    lengths = [0] * len(header)

    for idx, field in enumerate(header):
        maxlen = max([len(d[field[0]])+1 for d in data] + [len(field[1]) + 4])
        lengths[idx] = maxlen

    fmt = " ".join('{!s:<%d}'%l for l in lengths)

    print(fmt.format(*[c[1] for c in header]))
    for entry in data:
        print(fmt.format(*[entry[c[0]] for c in header]))

def without_http_prefix(url):
    """
    Returns a URL without the http:// or https:// prefixes
    """
    if url.startswith('http://'):
        return url[7:]
    elif url.startswith('https://'):
        return url[8:]
    return url

def http_get(url, args=None, auth=None):
    if args:
        url = url + '?' + urllib.urlencode(args, True)

    request = urllib2.Request(url)
    if auth:
        base64string = base64.encodestring(
            '%s:%s' % (auth[0], auth[1])).replace('\n', '')
        request.add_header('Authorization', 'Basic %s' % base64string)

    response = urllib2.urlopen(request)
    response_text = response.read()

    return response.getcode(), response_text

def http_post(url, data, auth=None):
    data_str = json.dumps(data)
    data_len = len(data_str)

    request = urllib2.Request(
        url,
        data_str,
        {'Content-Type': 'application/json',
         'Content-Length': data_len})

    if auth:
        base64string = base64.encodestring(
            '%s:%s' % (auth[0], auth[1])).replace('\n', '')
        request.add_header('Authorization', 'Basic %s' % base64string)

    response = urllib2.urlopen(request)
    response_text = response.read()

    return response.getcode(), response_text

def http_put(url, data, files=None, auth=None):
    if files:
        data, headers = encode_multipart(data, files)
    else:
        data = json.dumps(data)
        data_len = len(data)
        headers = {'Content-Type': 'application/json',
                   'Content-Length': data_len}

    request = urllib2.Request(
        url,
        data,
        headers
        )
    request.get_method = lambda: 'PUT'

    if auth:
        base64string = base64.encodestring(
            '%s:%s' % (auth[0], auth[1])).replace('\n', '')
        request.add_header('Authorization', 'Basic %s' % base64string)

    response = urllib2.urlopen(request)
    response_text = response.read()

    return response.getcode(), response_text

def http_delete(url, data, auth=None):
    data_str = json.dumps(data)
    data_len = len(data_str)

    request = urllib2.Request(
        url,
        data_str,
        {'Content-Type': 'application/json',
         'Content-Length': data_len})
    request.get_method = lambda: 'DELETE'

    if auth:
        base64string = base64.encodestring(
            '%s:%s' % (auth[0], auth[1])).replace('\n', '')
        request.add_header('Authorization', 'Basic %s' % base64string)

    response = urllib2.urlopen(request)
    response_text = response.read()

    return response.getcode(), response_text

def ps_command(host, is_quiet, auth):
    url = 'http://%s/api/groups' % without_http_prefix(host)

    try:
        _, data_str = http_get(url, None, auth)
    except urllib2.HTTPError, err:
        if err.code == 401:
            print("Authorization required")
            sys.exit(1)
        else:
            raise

    data = json.loads(data_str)

    result = []
    for group_id, group in data.items():
        for instance in group['instances']:

            result.append({
                'group_id': group_id,
                'instance_num': instance['name'],
                'name': group['name'],
                'type': group['type'],
                'memsize': str(group['memsize']),
                'mem_used': "{0:.3f}".format(instance['mem_used']),
                'state': group['state']['name'],
                'addr': instance['addr'],
                'port': str(instance['port']),
                'host': instance['host'],
            })

    header = [
        ('group_id', 'GROUP'),
        ('instance_num', 'INSTANCE #'),
        ('name', 'NAME'),
        ('type', 'TYPE'),
        ('memsize', 'SIZE'),
        ('mem_used', 'USED'),
        ('state', 'STATE'),
        ('addr', 'ADDRESS'),
        ('port', 'PORT'),
        ('host', 'NODE')
    ]

    if not is_quiet:
        print_table(header, result)
    else:
        groups = set([i['group_id'] for i in result])
        print('\n'.join(groups))


def inspect_command(host, group_id_list, auth):
    result = []
    for group_id in group_id_list:
        url = 'http://%s/api/groups/%s' % (without_http_prefix(host), group_id)
        data_str = None
        try:
            _, data_str = http_get(url, None, auth)
        except urllib2.HTTPError, err:
            if err.code == 404:
                print("No such group: '%s'" % group_id)
                sys.exit(1)
            elif err.code == 401:
                print("Authorization required")
                sys.exit(1)
            else:
                raise
        data = json.loads(data_str)

        # More important fields should be displayed on top
        ordered_data = collections.OrderedDict()
        keys = [k for k in GROUP_KEY_ORDER if k in data.keys()]
        keys = keys + [k for k in data.keys() if k not in keys]
        for key in keys:
            ordered_data[key] = data[key]
        result.append(ordered_data)
    print(json.dumps(result, indent=2))


def run_command(host, instance_type,
                name, memsize, password, auth, verbose):
    args = {'type': instance_type,
            'name': name,
            'memsize': memsize,
            'async': True}

    if password:
        args['password'] = password

    url = 'http://%s/api/groups' % without_http_prefix(host)

    try:
        _, data_str = http_post(url, args, auth)
    except urllib2.HTTPError, err:
        if err.code == 401:
            print("Authorization required")
            sys.exit(1)
        else:
            raise

    data = json.loads(data_str)

    task_id = data['task_id']
    group_id = data['id']

    status = "running"
    index = 0
    while status == "running":
        url = 'http://%s/api/tasks/%s' % (without_http_prefix(host), task_id)
        args = {"index": index}
        try:
            _, data_str = http_get(url, args, auth)
        except urllib2.HTTPError, err:
            if err.code == 401:
                print("Authorization required")
                sys.exit(1)
            else:
                raise
        data = json.loads(data_str)
        index = data['index']
        status = data['status']
        for log in data['logs']:
            if verbose:
                print(log['message'])
            else:
                print('.', end='')
                sys.stdout.flush()

        if status == "error":
            print("Error: %s" % data['message'])
            sys.exit(1)

    if not verbose:
        print('')

    print(group_id)

def rm_command(host, group_id_list, auth, verbose):
    for group_id in group_id_list:
        url = 'http://%s/api/groups/%s' % (without_http_prefix(host), group_id)
        try:
            _, data_str = http_delete(url, {'async': True}, auth)
        except urllib2.HTTPError, err:
            if err.code == 404:
                print("No such group: '%s'" % group_id)
                sys.exit(1)
            elif err.code == 401:
                print("Authorization required")
                sys.exit(1)
            else:
                raise

        data = json.loads(data_str)
        task_id = data['task_id']

        status = "running"
        index = 0
        while status == "running":
            url = 'http://%s/api/tasks/%s' % (without_http_prefix(host), task_id)
            args = {"index": index}
            try:
                _, data_str = http_get(url, args, auth)
            except urllib2.HTTPError, err:
                if err.code == 401:
                    print("Authorization required")
                    sys.exit(1)
                else:
                    raise
            data = json.loads(data_str)
            index = data['index']
            status = data['status']
            for log in data['logs']:
                if verbose:
                    print(log['message'])
                else:
                    print('.', end='')
                    sys.stdout.flush()

            if status == "error":
                print("Error: %s" % data['message'])
                sys.exit(1)

    if not verbose:
        print('')


def update_command(host, group_id, name, memsize, password, config, heal,
                   auth, verbose):
    data = {'async': True}
    files = None
    if heal:
        data['heal'] = True
    if name:
        data['name'] = name
    if memsize:
        data['memsize'] = memsize
    if password:
        data['password'] = password
    if config:
        config = os.path.expanduser(config)
        config = os.path.realpath(config)
        filedata = None
        if os.path.isdir(config):
            out = StringIO.StringIO()
            tar = tarfile.open(fileobj=out, mode="w:gz")
            tar.add(config, arcname=".")
            tar.close()
            filename = 'config.tar.gz'
            filedata = out.getvalue()
            is_dir = True
        else:
            filename = os.path.basename(config)
            filedata = open(config).read()
            is_dir = False

        files = {'config': {'filename': filename,
                            'content': filedata}}
        data['config_is_dir'] = is_dir

    url = 'http://%s/api/groups/%s' % (without_http_prefix(host), group_id)

    try:
        _, data_str = http_put(url, data, files=files, auth=auth)
    except urllib2.HTTPError, err:
        if err.code == 404:
            print("No such group: '%s'" % group_id)
            sys.exit(1)
        elif err.code == 401:
            print("Authorization required")
            sys.exit(1)
        else:
            raise

    data = json.loads(data_str)
    task_id = data['task_id']

    status = "running"
    index = 0
    while status == "running":
        url = 'http://%s/api/tasks/%s' % (without_http_prefix(host), task_id)
        args = {"index": index}
        try:
            _, data_str = http_get(url, args, auth)
        except urllib2.HTTPError, err:
            if err.code == 401:
                print("Authorization required")
                sys.exit(1)
            else:
                raise
        data = json.loads(data_str)
        index = data['index']
        status = data['status']

        for log in data['logs']:
            if verbose:
                print(log['message'])
            else:
                print('.', end='')
                sys.stdout.flush()

        if status == "error":
            print("Error: %s" % data['message'])
            sys.exit(1)

    if not verbose:
        print('')

def upgrade_command(host, group_id, auth, verbose):
    data = {'async': True,
            'docker_image_name': 'tarantool-cloud-memcached'}

    url = 'http://%s/api/groups/%s' % (without_http_prefix(host), group_id)

    try:
        _, data_str = http_put(url, data, auth=auth)
    except urllib2.HTTPError, err:
        if err.code == 404:
            print("No such group: '%s'" % group_id)
            sys.exit(1)
        elif err.code == 401:
            print("Authorization required")
            sys.exit(1)
        else:
            raise

    data = json.loads(data_str)
    task_id = data['task_id']

    status = "running"
    index = 0
    while status == "running":
        url = 'http://%s/api/tasks/%s' % (without_http_prefix(host), task_id)
        args = {"index": index}
        try:
            _, data_str = http_get(url, args, auth)
        except urllib2.HTTPError, err:
            if err.code == 401:
                print("Authorization required")
                sys.exit(1)
            else:
                raise
        data = json.loads(data_str)
        index = data['index']
        status = data['status']
        for log in data['logs']:
            if verbose:
                print(log['message'])
            else:
                print('.', end='')
                sys.stdout.flush()

        if status == "error":
            print("Error: %s" % data['message'])
            sys.exit(1)

    if not verbose:
        print('')

def backup_command(host, group_id, auth, verbose):
    args = {'async': True}

    url = 'http://%s/api/groups/%s/backups' % (without_http_prefix(host),
                                               group_id)

    try:
        _, data_str = http_post(url, args, auth)
    except urllib2.HTTPError, err:
        if err.code == 500:
            data = json.loads(err.read())
            print("Failed to back up: %s" % data['message'])
            sys.exit(1)
        if err.code == 401:
            print("Authorization required")
            sys.exit(1)
        else:
            raise

    data = json.loads(data_str)

    task_id = data['task_id']
    group_id = data['id']

    status = "running"
    index = 0
    while status == "running":
        url = 'http://%s/api/tasks/%s' % (without_http_prefix(host), task_id)
        args = {"index": index}
        try:
            _, data_str = http_get(url, args, auth)
        except urllib2.HTTPError, err:
            if err.code == 500:
                data = json.loads(err.read())
                print("Failed to back up: %s" % data['message'])
                sys.exit(1)
            if err.code == 401:
                print("Authorization required")
                sys.exit(1)
            else:
                raise
        data = json.loads(data_str)
        index = data['index']
        status = data['status']
        for log in data['logs']:
            if verbose:
                print(log['message'])
            else:
                print('.', end='')
                sys.stdout.flush()

        if status == "error":
            print("Error: %s" % data['message'])
            sys.exit(1)

    if not verbose:
        print('')

    print(group_id)


def restore_command(host, group_id, backup_id, auth, verbose):
    args = {'async': True,
            'backup_id': backup_id}

    url = 'http://%s/api/groups/%s' % (without_http_prefix(host),
                                       group_id)

    try:
        _, data_str = http_put(url, args, auth)
    except urllib2.HTTPError, err:
        if err.code == 500:
            data = json.loads(err.read())
            print("Failed to restore: %s" % data['message'])
            sys.exit(1)
        if err.code == 404:
            print("No such group: '%s'" % group_id)
            sys.exit(1)
        if err.code == 401:
            print("Authorization required")
            sys.exit(1)
        else:
            raise

    data = json.loads(data_str)
    task_id = data['task_id']

    status = "running"
    index = 0
    while status == "running":
        url = 'http://%s/api/tasks/%s' % (without_http_prefix(host), task_id)
        args = {"index": index}
        try:
            _, data_str = http_get(url, args, auth)
        except urllib2.HTTPError, err:
            if err.code == 401:
                print("Authorization required")
                sys.exit(1)
            else:
                raise
        data = json.loads(data_str)
        index = data['index']
        status = data['status']

        for log in data['logs']:
            if verbose:
                print(log['message'])
            else:
                print('.', end='')
                sys.stdout.flush()

        if status == "error":
            print("Error: %s" % data['message'])
            sys.exit(1)

    if not verbose:
        print('')

def backups_ls_command(host, is_quiet, auth):
    url = 'http://%s/api/backups' % without_http_prefix(host)

    try:
        _, data_str = http_get(url, None, auth)
    except urllib2.HTTPError, err:
        if err.code == 401:
            print("Authorization required")
            sys.exit(1)
        else:
            raise

    data = json.loads(data_str)

    result = []
    for backup_id, backup in data.items():
        result.append({
            'backup_id': backup_id,
            'type': backup['type'],
            'size': "{0:.3f}".format(backup['size'] / 1024 ** 3),
            'mem_used': "{0:.3f}".format(backup['mem_used']),
            'time': backup['creation_time'].split('.')[0]
        })

    result = sorted(result, key=lambda x: x['time'], reverse=True)

    header = [
        ('backup_id', 'BACKUP'),
        ('type', 'TYPE'),
        ('size', 'SIZE'),
        ('mem_used', 'MEM USED'),
        ('time', 'TIME')
    ]

    if not is_quiet:
        print_table(header, result)
    else:
        groups = set([i['backup_id'] for i in result])
        print('\n'.join(groups))

def backups_rm_command(host, backup_id_list, auth, verbose):
    for backup_id in backup_id_list:
        url = 'http://%s/api/backups/%s' % (without_http_prefix(host), backup_id)
        try:
            _, data_str = http_delete(url, {'async': True}, auth)
        except urllib2.HTTPError, err:
            if err.code == 500:
                data = json.loads(err.read())
                print("Failed remove backup: %s" % data['message'])
                sys.exit(1)
            if err.code == 404:
                print("No such backup: '%s'" % backup_id)
                sys.exit(1)
            elif err.code == 401:
                print("Authorization required")
                sys.exit(1)
            else:
                raise

        data = json.loads(data_str)
        task_id = data['task_id']

        status = "running"
        index = 0
        while status == "running":
            url = 'http://%s/api/tasks/%s' % (without_http_prefix(host), task_id)
            args = {"index": index}
            try:
                _, data_str = http_get(url, args, auth)
            except urllib2.HTTPError, err:
                if err.code == 401:
                    print("Authorization required")
                    sys.exit(1)
                else:
                    raise
            data = json.loads(data_str)
            index = data['index']
            status = data['status']
            for log in data['logs']:
                if verbose:
                    print(log['message'])
                else:
                    print('.', end='')
                    sys.stdout.flush()

            if status == "error":
                print("Error: %s" % data['message'])
                sys.exit(1)

    if not verbose:
        print('')


def main():
    # Don't spam with HTTP connection logs from 'requests' module
    logging.getLogger("requests").setLevel(logging.WARNING)

    parser = argparse.ArgumentParser()

    parser.add_argument('-H', '--host',
                        default = None,
                        help='specify taas host to connect to')

    parser.add_argument('-v', '--verbose',
                        action='store_true',
                        default=False,
                        help='enable verbose output')

    parser.add_argument('-u', '--username',
                        help='User name for HTTP Basic Auth')

    parser.add_argument('-p', '--password',
                        help='Password for HTTP Basic Auth')

    subparsers = parser.add_subparsers(title="commands", dest="subparser_name")

    ps_parser = subparsers.add_parser(
        'ps', help='show a list of running groups')
    ps_parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='only show group IDs')

    inspect_parser = subparsers.add_parser(
        'inspect', help='inspect a group')
    inspect_parser.add_argument(
        'group_id',
        nargs='+',
        help='group to inspect')

    run_parser = subparsers.add_parser(
        'run', help='run a new group')
    run_parser.add_argument(
        '--name',
        help='name of the new group')
    run_parser.add_argument(
        '--memsize',
        type=float,
        help='amount of memory to allocate, in GiB (default is 0.5)',
        nargs='?',
        default=0.5)
    run_parser.add_argument(
        '--password',
        help='password for accessing this group')
    run_parser.add_argument(
        'type',
        help='instance type to run (default is memcached)',
        default='memcached', nargs='?')

    rm_parser = subparsers.add_parser(
        'rm', help='remove one or more groups')
    rm_parser.add_argument(
        'group_id',
        nargs='+',
        help='group to remove')

    update_parser = subparsers.add_parser(
        'update', help='update an existing group')
    update_parser.add_argument('--memsize',
                               type=float,
                               help='amount of memory to set',
                               default=None)
    update_parser.add_argument('--name',
                               help='name to set',
                               default=None)
    update_parser.add_argument('--config',
                               help='configuration file to update',
                               default=None)

    update_parser.add_argument(
        '--password',
        help='password for accessing this group via memcached protocol')

    update_parser.add_argument('group_id',
                               help='group ID to update')

    heal_parser = subparsers.add_parser(
        'heal', help='heal an existing group')
    heal_parser.add_argument('group_id',
                             help='group ID to heal')

    upgrade_parser = subparsers.add_parser(
        'upgrade', help='upgrade an existing group')
    upgrade_parser.add_argument('group_id',
                                help='group ID to upgrade')

    deploy_parser = subparsers.add_parser(
        'deploy', help='deploy configuration to an existing group')
    deploy_parser.add_argument('group_id',
                                help='group ID to deploy to')
    deploy_parser.add_argument('path',
                                help='path to deploy from')

    backup_parser = subparsers.add_parser(
        'backup', help='backup an existing group')
    backup_parser.add_argument('group_id',
                               help='group ID to backup')

    restore_parser = subparsers.add_parser(
        'restore', help='restore an existing group from backup')
    restore_parser.add_argument('group_id',
                                help='group ID to restore')
    restore_parser.add_argument('backup_id',
                                help='backup ID to restore from')

    backup_parser = subparsers.add_parser(
        'backups', help='manage backups')

    backup_subparsers = backup_parser.add_subparsers(
        title="commands",
        dest="backup_subparser_name")

    backup_ls_parser = backup_subparsers.add_parser('ls')
    backup_ls_parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='only show backup IDs')

    backup_rm_parser = backup_subparsers.add_parser(
        'rm', help='remove one or more backups')
    backup_rm_parser.add_argument(
        'backup_id',
        nargs='+',
        help='backup to remove')

    args = parser.parse_args()

    auth = None
    if args.username and args.password:
        auth = (args.username, args.password)

    host = None
    if args.host is None:
        if 'TARANTOOL_CLOUD_HOST' in os.environ:
            host = os.environ['TARANTOOL_CLOUD_HOST']
        else:
            sys.exit("Please specify --host or pass TARANTOOL_CLOUD_HOST via env")
    else:
        host = args.host

    if args.subparser_name == 'ps':
        ps_command(host, args.quiet, auth)
    if args.subparser_name == 'inspect':
        inspect_command(host, args.group_id, auth)
    elif args.subparser_name == 'run':
        run_command(host, args.type,
                    args.name, args.memsize, args.password,
                    auth, args.verbose)
    elif args.subparser_name == 'rm':
        rm_command(host, args.group_id, auth, args.verbose)
    elif args.subparser_name == 'update':
        update_command(host, args.group_id, args.name,
                       args.memsize, args.password, args.config, False,
                       auth, args.verbose)
    elif args.subparser_name == 'upgrade':
        upgrade_command(host, args.group_id, auth, args.verbose)
    elif args.subparser_name == 'heal':
        update_command(host, args.group_id, None,
                       None, None, None, True,
                       auth, args.verbose)
    elif args.subparser_name == 'deploy':
        update_command(host, args.group_id, None,
                       None, None, args.path, False,
                       auth, args.verbose)
    elif args.subparser_name == 'backup':
        backup_command(host, args.group_id, auth, args.verbose)
    elif args.subparser_name == 'restore':
        restore_command(host, args.group_id, args.backup_id, auth, args.verbose)
    elif args.subparser_name == 'backups' and args.backup_subparser_name == 'ls':
        backups_ls_command(host, args.quiet, auth)
    elif args.subparser_name == 'backups' and args.backup_subparser_name == 'rm':
        backups_rm_command(host, args.backup_id, auth, args.verbose)

if __name__ == '__main__':
    main()
